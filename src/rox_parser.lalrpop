use crate::roxc::{Block, Declaration, Expression, Identifier, Operation, Param, Statement, Unary};
use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

pub Program: Vec<Declaration> = {
    <(<TopLevelFunctionDeclaration>)*>
}

TopLevelFunctionDeclaration: Declaration = {
    <Function> => Declaration::Function(<>),
}

Function: Box<Statement> = {
    "fn" <Identifier> "(" <Params> ")" <(ReturnType)?> <Block> => Box::new(Statement::FunctionDeclaration(<>))
}

Block: Block = {
    "{" <(<Statement>)*> "}",
}

Statement: Box<Statement> = {
    <Expression> ";" => Box::new(Statement::Expression(<>)),
    <ReturnStatement>,
    <Function> ";",
    "if" <Expression> <Block> <("else" <Block>)?> => Box::new(Statement::IfElse(<>)),
    <Block> ";" => Box::new(Statement::Block(<>)),
}

ReturnStatement: Box<Statement> = {
    "return" <Expression> ";" => Box::new(Statement::Return(Some(<>))),
    "return" ";" => Box::new(Statement::Return(None)),
}

Expression: Box<Expression> = {
    Assignment
}

Assignment: Box<Expression> = {
    // TODO: Allow for assignment to function results
    // i.e. `some_call().attribute = 3;`
    <NonGenericIdentifier> "=" <Assignment> => Box::new(Expression::Assignment(<>)),
    "let" <NonGenericIdentifier> "=" <Assignment> => Box::new(Expression::Variable(<>)),
    LogicOr
}

LogicOr: Box<Expression> = {
    <LogicAnd> "or" <LogicAnd> => Box::new(Expression::Or(<>)),
    LogicAnd
}

LogicAnd: Box<Expression> = {
    <Equality> "and" <Equality> => Box::new(Expression::And(<>)),
    Equality
}

Equality: Box<Expression> = {
    Comparison EqualityOp Comparison => Box::new(Expression::Operation(<>)),
    Comparison
}

Comparison: Box<Expression> = {
    Addition ComparisonOp Addition => Box::new(Expression::Operation(<>)),
    Addition
}

// TODO: support multiple operators one after another
// TODO: i.e. support `1 + 2 + 3`
Addition: Box<Expression> = {
    Multiplication AdditionOp Multiplication => Box::new(Expression::Operation(<>)),
    Multiplication
}

Multiplication: Box<Expression> = {
    Unary MultiplicationOp Unary => Box::new(Expression::Operation(<>)),
    Unary
}

Unary: Box<Expression> = {
    "!" <Unary> => Box::new(Expression::Unary(Unary::Not, <>)),
    "-" <Unary> => Box::new(Expression::Unary(Unary::Negate, <>)),
    Call,
};

Call: Box<Expression> = {
    <i: NonGenericIdentifier> "(" <args: (Arguments)?> ")" => Box::new(Expression::FunctionCall(i, args.unwrap_or(Vec::new()))),
    Primary
}

ComparisonOp: Operation = {
    ">" => Operation::GreaterThan,
    "<" => Operation::LessThan,
}

EqualityOp: Operation = {
    "==" => Operation::Equals,
    "!=" => Operation::NotEquals,
}

Params: Vec<Param> = {
    <first:(Param)?> <mut rest: ("," <Param>)*> ","? => {
        if let Some(first_param) = first {
            rest.insert(0, first_param);
        }
        rest
    }
}

Param: Param = {
    <i:NonGenericIdentifier> ":" <t:Identifier> => (i, t)
}

ReturnType: Identifier = {
    "->" <Identifier>
}

Arguments: Vec<Box<Expression>> = {
    <mut args:Arguments> "," <expr:Expression> => {
        args.push(expr);
        args
    },
    <Expression> => vec!(<>),
}

MultiplicationOp: Operation = {
    "*" => Operation::Multiply,
    "/" => Operation::Divide,
};

AdditionOp: Operation = {
    "+" => Operation::Add,
    "-" => Operation::Subtract,
};

Primary: Box<Expression> = {
    Boolean => Box::new(Expression::Boolean(<>)),
    Num => Box::new(Expression::Number(<>)),
    String => Box::new(Expression::String(<>)),
    NonGenericIdentifier => Box::new(Expression::Identifier(<>)),
    "(" <Expression> ")",
    "[" <Comma<Expression>> "]" => Box::new(Expression::Array(<>)),
    ! => {
        errors.push(<>);
        Box::new(Expression::ParseError)
    }
};

Boolean: bool = {
    "true" => true,
    "false" => false,
}

Identifier: Identifier = { GenericIdentifier, NonGenericIdentifier }

GenericIdentifier: Identifier = {
    <i: NonGenericIdentifier> "<" <generics: Comma<Identifier>> ">" => Identifier::new(i.get_name(), generics),
}

NonGenericIdentifier: Identifier = {
    r"[a-zA-Z_]([a-zA-Z0-9_?!-])*" => Identifier::new(String::from(<>), Vec::new())
}

Num: f64 = {
    r"[0-9]+(\.)?([0-9]+)?" => f64::from_str(<>).unwrap()
};

String: String = {
    r#""[^"]*""# => <>.chars().skip(1).take(<>.len()-2).collect::<String>()
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};