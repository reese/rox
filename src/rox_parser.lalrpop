use crate::roxc::{Block, Expression, Identifier, Operation, Param, TypeName, Statement, Unary};
use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

pub Program: Vec<Box<Statement>> = {
    <(<Statement>)*>
}

Function: Box<Statement> = {
    "fn" <Identifier> <("<" <Comma<Identifier>> ">")?> "(" <Params> ")" <("->" <Type>)?> <Block> => Box::new(Statement::FunctionDeclaration(<>)),
    "extern" "fn" <Identifier> "(" <Comma<Type>> ")" <("->" <Type>)?> ";" => Box::new(Statement::ExternFunctionDeclaration(<>))
}

StructDeclaration: Box<Statement> = {
    "struct" <Identifier> <("<" <Comma<Identifier>> ">")?> "{" <Comma<Param>> "}" => Box::new(Statement::StructDeclaration(<>))
}

Block: Block = {
    "do" <(<Statement>)*> "end",
}

Statement: Box<Statement> = {
    <Expression> ";" => Box::new(Statement::Expression(<>)),
    <ReturnStatement>,
    <Function>,
    <StructDeclaration>,
    "if" <Expression> <Block> <("else" <Block>)?> => Box::new(Statement::IfElse(<>)),
}

ReturnStatement: Box<Statement> = {
    "return" <(Expression)?> ";" => Box::new(Statement::Return(<>)),
}

Expression: Box<Expression> = {
    Assignment
}

Assignment: Box<Expression> = {
    // TODO: Allow for assignment to function results
    // i.e. `some_call().attribute = 3;`
    <Call> "=" <Assignment> => Box::new(Expression::Assignment(<>)),
    "let" <Identifier> "=" <Assignment> => Box::new(Expression::Variable(<>)),
    <Identifier><("::" "<" <Comma<Type>> ">")?> "{" <Comma<(<Identifier> ":" <Expression>)>> "}" => Box::new(Expression::StructInstantiation(<>)),
    LogicOr
}

LogicOr: Box<Expression> = {
    <LogicAnd> "or" <LogicAnd> => Box::new(Expression::Or(<>)),
    LogicAnd
}

LogicAnd: Box<Expression> = {
    <Equality> "and" <Equality> => Box::new(Expression::And(<>)),
    Equality
}

Equality: Box<Expression> = {
    Comparison EqualityOp Comparison => Box::new(Expression::Operation(<>)),
    Comparison
}

Comparison: Box<Expression> = {
    Addition ComparisonOp Addition => Box::new(Expression::Operation(<>)),
    Addition
}

// TODO: support multiple operators one after another
// TODO: i.e. support `1 + 2 + 3`
Addition: Box<Expression> = {
    Multiplication AdditionOp Multiplication => Box::new(Expression::Operation(<>)),
    Multiplication
}

Multiplication: Box<Expression> = {
    Unary MultiplicationOp Unary => Box::new(Expression::Operation(<>)),
    Unary
}

Unary: Box<Expression> = {
    "!" <Unary> => Box::new(Expression::Unary(Unary::Not, <>)),
    "-" <Unary> => Box::new(Expression::Unary(Unary::Negate, <>)),
    Call,
};

Call: Box<Expression> = {
    <i: Identifier> <generics:( "::" "<" <Comma<Type>> ">")?> "(" <args: (Arguments)?> ")" =>
        Box::new(Expression::FunctionCall(i, generics.unwrap_or(Vec::new()), args.unwrap_or(Vec::new()))),
    Access,
    Primary
}

Access: Box<Expression> = {
    <Call> "[" <Call> "]" => Box::new(Expression::Access(<>)),
}

ComparisonOp: Operation = {
    ">" => Operation::GreaterThan,
    "<" => Operation::LessThan,
}

EqualityOp: Operation = {
    "==" => Operation::Equals,
    "!=" => Operation::NotEquals,
}

Params: Vec<Param> = {
    <first:(Param)?> <mut rest: ("," <Param>)*> ","? => {
        if let Some(first_param) = first {
            rest.insert(0, first_param);
        }
        rest
    }
}

Param: Param = {
    <i:Identifier> ":" <t:Type> => (i, t)
}

Arguments: Vec<Box<Expression>> = {
    <mut args:Arguments> "," <expr:Expression> => {
        args.push(expr);
        args
    },
    <Expression> => vec!(<>),
}

MultiplicationOp: Operation = {
    "*" => Operation::Multiply,
    "/" => Operation::Divide,
};

AdditionOp: Operation = {
    "+" => Operation::Add,
    "-" => Operation::Subtract,
};

Primary: Box<Expression> = {
    Boolean => Box::new(Expression::Boolean(<>)),
    Float => Box::new(Expression::Float(<>)),
    Int => Box::new(Expression::Int(<>)),
    String => Box::new(Expression::String(<>)),
    Identifier => Box::new(Expression::Identifier(<>)),
    "(" <Expression> ")",
    "[" <Comma<Expression>> "]" => Box::new(Expression::Array(<>)),
    ! => {
        errors.push(<>);
        Box::new(Expression::ParseError)
    }
};

Identifier: Identifier = {
    r"[a-zA-Z_]([a-zA-Z0-9_?!-])*" => String::from(<>)
}

Type: Box<TypeName> = {
    Identifier => Box::new(TypeName::Type(<>)),
    <i: Identifier> "<" <t:Comma<Type>> ">" => Box::new(TypeName::GenericType(<>)),
    FunctionType,
}

FunctionType: Box<TypeName> = {
    "(" <types:Comma<Type>> ")" "->" <t:Type> => Box::new(TypeName::Function(types, t)),
}

Boolean: bool = {
    "true" => true,
    "false" => false,
}

Float: f64 = {
    r"[0-9]+(\.)([0-9]+)?" => f64::from_str(<>).unwrap()
};

Int: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
}

String: String = {
    r#""[^"]*""# => <>.chars().skip(1).take(<>.len()-2).collect::<String>()
}

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};
