use crate::interpreter::{Block, Declaration, Expression, Operation, Statement, Unary};
use std::str::FromStr;
use lalrpop_util::ErrorRecovery;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

pub Program: Vec<Declaration> = {
    <(<Declaration>)*>
}

Declaration: Declaration = {
    <Statement> => Declaration::Statement(<>),
    "let" <Identifier> "=" <TopExpression> ";" => Declaration::Variable(<>),
}

Statement: Box<Statement> = {
    <TopExpression> ";" => Box::new(Statement::Expression(<>)),
    <Block> => Box::new(Statement::Block(<>)),
    "if" <TopExpression> <Block> <("else" <Block>)?> => Box::new(Statement::IfElse(<>)),
    "while" <LogicOr> <Block> => Box::new(Statement::While(<>)),
    "print" <TopExpression> ";" => Box::new(Statement::Print(<>)),
    "return" <e:TopExpression?> ";" => match e {
        None => Box::new(Statement::Return(None)),
        Some(e) => Box::new(Statement::Return(Some(e))),
    }
};

TopExpression: Box<Expression> = {
    <Assignment>
}

Block: Block = {
    "{" <(<Declaration>)*> "}",
}

Assignment: Box<Expression> = {
    <Identifier> "=" <Assignment> => Box::new(Expression::Assignment(<>)),
    <LogicOr>
}

LogicOr: Box<Expression> = {
    <Expression> "or" <Expression> => Box::new(Expression::Or(<>)),
    <LogicAnd>
}

LogicAnd: Box<Expression> = {
    <Expression> "and" <Expression> => Box::new(Expression::And(<>)),
    <Expression>
}

Expression: Box<Expression> = {
    Boolean => Box::new(Expression::Boolean(<>)),
    Expression ExpressionOp Factor => Box::new(Expression::Operation(<>)),
    Factor,
    ! => {
        errors.push(<>);
        Box::new(Expression::ParseError)
    }
};

Factor: Box<Expression> = {
    Factor FactorOp Term => Box::new(Expression::Operation(<>)),
    Term,
    Comparison,
};

Comparison: Box<Expression> = {
    Factor ComparisonOp Term => Box::new(Expression::Operation(<>))
}

ComparisonOp: Operation = {
    ">" => Operation::GreaterThan,
    "<" => Operation::LessThan,
    "==" => Operation::Equals,
    "!=" => Operation::NotEquals,
}

FactorOp: Operation = {
    "*" => Operation::Multiply,
    "/" => Operation::Divide,
    "%" => Operation::Modulo,
};

ExpressionOp: Operation = {
    "+" => Operation::Add,
    "-" => Operation::Subtract,
};

Term: Box<Expression> = {
    Num => Box::new(Expression::Number(<>)),
    Identifier => Box::new(Expression::Identifier(<>)),
    String => Box::new(Expression::String(<>)),
    Unary Term => Box::new(Expression::Unary(<>)),
    "(" <Expression> ")"
};

Unary: Unary = {
    "!" => Unary::Not,
    "-" => Unary::Negate,
};

Boolean: bool = {
    "true" => true,
    "false" => false,
}

Identifier: String = {
    r"[a-zA-Z_]([a-zA-Z0-9_])*" => String::from(<>)
}

Num: f64 = {
    r"[0-9]+(\.)?([0-9]+)?" => f64::from_str(<>).unwrap()
};

String: String = {
    r#""[^"]*""# => String::from(<>)
}
